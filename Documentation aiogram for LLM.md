# **Aiogram 3.x – Подробное руководство для создания Telegram-ботов**
**Aiogram** – это современный асинхронный фреймворк на Python для разработки ботов Telegram. Он использует возможности asyncio и позволяет максимально эффективно обрабатывать обновления из Telegram . В данной документации представлено пошаговое руководство на русском языке по работе с aiogram версии 3.x. Вы узнаете, как правильно структурировать проект, регистрировать обработчики событий, применять фильтры, использовать конечные автоматы состояний (FSM), подключать middleware, обрабатывать данные callback, создавать клавиатуры, запускать фоновые задачи, вызывать методы Telegram API, а также настраивать бота в режиме _polling_ и _webhook_. Кроме того, мы рассмотрим обработку ошибок, логирование и поделимся советами по архитектуре бота.
## **Установка и структура проекта**
### **Установка библиотеки**
Для начала работы установите aiogram версии 3.x через pip (убедитесь, что у вас Python 3.8+):
```
pip install aiogram
```
Также рекомендуется создать виртуальное окружение для проекта и хранить токен бота и другие настройки в файле окружения (например, .env). Для загрузки переменных окружения можно использовать пакет **python-dotenv**.
## **Структура проекта**
Организуйте файлы проекта так, чтобы код было легко поддерживать. Например, минимальная структура может выглядеть так:
- bot.py – главный файл запуска бота (инициализация Bot и Dispatcher, запуск polling/webhook).
- config.py – файл конфигурации (токен API, настройки вебхука и пр.).
- Пакет handlers/ – пакеты или модули с обработчиками (например, handlers/users.py, handlers/admin.py).
- Пакет middlewares/ – модули с middleware.
- Пакет filters/ – модули с пользовательскими фильтрами.
- Пакет states/ – описание состояний FSM.
- Пакет keyboards/ – сборка клавиатур (inline и reply).
Такая структура помогает разделить логику по смысловым блокам. В крупных проектах удобно использовать **Router** (маршрутизатор) для группировки обработчиков по модулям и затем подключать их к **Dispatcher** (глобальному маршрутизатору) при запуске приложения.
**Пример минимального бота** – файл bot.py:
```
import asyncio
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
API_TOKEN = "<ТОКЕН_ВАШЕГО_БОТА>"
# Инициализация объектов Bot и Dispatcher
bot = Bot(token=API_TOKEN)
dp = Dispatcher()
# Регистрация простого обработчика команды /start
@dp.message(Command("start"))
async def start_command(message: types.Message):
await message.answer("Привет! Я ваш бот, чем могу помочь?")
async def main():
# Запуск долгого опроса (polling)
await dp.start_polling(bot)
if __name__ == "__main__":
asyncio.run(main())
```
**Что здесь происходит?** Мы создаём объект **Bot** с токеном вашего бота, полученным у [BotFather](https://t.me/BotFather). Затем создаётся **Dispatcher** – механизм, который будет принимать обновления (update) от Telegram и отправлять их в соответствующие обработчики. Мы регистрируем обработчик для команды /start через декоратор @dp.message(...) с фильтром Command("start"). Этот обработчик отвечает пользователю сообщением. В функции main() запускается метод dp.start_polling(bot) – он подключается к серверам Telegram и начинает получать обновления бесконечным циклом (**Long Polling**). В блоке if __name__ == "__main__": через asyncio.run(main()) стартует асинхронное приложение.
После запуска этого скрипта бот будет в режиме polling ждать сообщений. Если ему написать команду /start, сработает наш обработчик и отправит ответ.
## **Основные объекты: Bot, Dispatcher, Router**
### **Bot – взаимодействие с Telegram API**
**Bot** – основной объект, через который осуществляется вызов методов Telegram Bot API (отправка сообщений, фото, и т.д.). При создании Bot(token=...) вы передаёте токен. Объект Bot предоставляет такие методы, как send_message(), send_photo(), ban_chat_member() и все остальные методы API. Вы можете вызывать их напрямую, указав все необходимые параметры (идентификаторы чата, текст сообщений и др.) . Пример прямого вызова:
```
await bot.send_message(chat_id=123456, text="Пример прямого вызова метода")
```
Aiogram упрощает работу с API, позволяя вызывать методы не только через Bot, но и через объекты событий (например, объект сообщения). Практически каждый объект обновления содержит **алиасы** методов Bot. Например, объект message: types.Message имеет метод answer(), который автоматически подставит chat_id текущего чата . То есть следующие вызовы эквивалентны:
```
# Через Bot
await bot.send_message(chat_id=message.chat.id, text="Hello")
# Через объект Message (алиас answer)
await message.answer("Hello")
```
Второй вариант короче и удобнее в обработчиках. Аналогично, у CallbackQuery есть метод answer(), у InlineQuery – метод answer() для отправки результатов и т.д. Эти методы-алиасы знают контекст события и позволяют писать код чище .
### **Dispatcher – диспетчер событий**
**Dispatcher** – объект, управляющий маршрутизацией входящих **обновлений** (updates) к зарегистрированным обработчикам. В aiogram 3.x **Dispatcher** сам по себе является маршрутизатором (наследует класс Router), поэтому вы можете регистрировать обработчики как напрямую на Dispatcher, так и на Router’ы, подключаемые к нему. Обычно создаётся один Dispatcher, к которому могут быть подключены один или несколько Router.
Когда Telegram присылает обновление (например, новое сообщение, нажатие кнопки, запрос инлайн-режима и т.п.), Dispatcher получает его и последовательно проверяет, нет ли зарегистрированного обработчика, чей фильтр подходит под данное событие. **Важно:** как только найден первый подходящий обработчик, остальные не выполняются (обработчики не «накладываются» друг на друга) . Поэтому порядок регистрации имеет значение: более специфичные обработчики стоит регистрировать раньше общих. Если обработчик зарегистрирован без фильтров, он получит _любое_ событие данного типа, поэтому такие хендлеры лучше располагать последними .
Запуск Dispatcher осуществляется методом start_polling(), которому передаётся объект Bot. Polling – это длинный опрос getUpdates у Telegram. Можно также использовать start_webhook() для запуска в режиме вебхуков (о вебхуках – ниже).
### **Router – маршрутизатор обработчиков**
**Router** – это компонент для группировки обработчиков. Вы можете создавать отдельные Router для разных модулей или функциональностей (например, user_router для пользовательских команд, admin_router для административных команд, fsm_router для сценариев с состояниями и т.д.). После описания обработчиков на этих роутерах вы **подключаете** их к основному диспетчеру с помощью dp.include_router(router) .
Использование Router повышает модульность: обработчики можно объявлять в разных файлах, не импортируя глобальный Dispatcher. В конце достаточно подключить все маршрутизаторы к Dispatcher в основном файле.
**Пример использования Router:**
```
# В файле handlers/users.py
from aiogram import Router
from aiogram.filters import Command
from aiogram.types import Message
user_router = Router()
@user_router.message(Command("help"))
async def user_help(message: Message):
await message.answer("Это справка для пользователей.")
# В файле handlers/admin.py
admin_router = Router()
@admin_router.message(Command("stats"))
async def admin_stats(message: Message):
await message.answer("Статистика бота: ...")
# В основном файле bot.py
from aiogram import Bot, Dispatcher
from handlers.users import user_router
from handlers.admin import admin_router
bot = Bot(token=API_TOKEN)
dp = Dispatcher()
dp.include_router(user_router)
dp.include_router(admin_router)
await dp.start_polling(bot)
```
Здесь мы создали два Router (user_router и admin_router) и зарегистрировали на каждом свои обработчики. В bot.py оба маршрутизатора подключаются к диспетчеру. В итоге, когда придёт команда /help, сработает обработчик из user_router, а при команде /stats – из admin_router. Эта структура предотвращает появление циклических импортов и делает код чище.
## **Регистрация обработчиков (Handlers)**
Обработчик – это асинхронная функция (корутина), которая вызывается, когда происходит определённое событие, и выполняет заданную логику (например, отправляет ответное сообщение). В aiogram 3.x для каждого типа событий (сообщения, нажатия кнопки, инлайн-запросы, ошибки и т.д.) предусмотрен свой декоратор для регистрации обработчика на **Router/Dispatcher**. Ниже рассмотрены основные виды обработчиков.
### **Обработчики сообщений**
**Обработчик сообщений** реагирует на входящие сообщения (тип Update: Message). Чтобы зарегистрировать такой обработчик, используйте декоратор @router.message(...) или @dp.message(...). В скобках можно передать один или несколько **фильтров**, определяющих условия срабатывания.
Простейший пример мы уже видели – обработчик команды /start:
```
@dp.message(Command("start"))
async def on_start(message: types.Message):
await message.answer("Бот запущен. Введите команду /help для справки.")
```
Здесь Command("start") – встроенный фильтр (объяснение фильтров – ниже), благодаря которому этот хендлер вызовется только для сообщений, начинающихся с /start . Если удалить фильтр или поставить @dp.message() без аргументов, обработчик будет реагировать **на все текстовые сообщения**, что эквивалентно сценарию эхо-бота. Например:
```
@dp.message()
async def echo_all(message: types.Message):
await message.answer(message.text)
```
Этот обработчик отправит пользователю обратно любой полученный текст (будьте осторожны с такими глобальными хендлерами – обычно их используют в качестве «поглотителя», чтобы перехватить несоответствующие другим фильтрам сообщения).
**Регистрация нескольких фильтров:** Если указать несколько фильтров через запятую, все они должны одновременно быть истинными (логическое И) для вызова обработчика . Например:
```
@dp.message(F.chat.type == "private", F.text.contains("привет"))
async def private_greeting(message: Message):
# Этот хендлер сработает только если сообщение в личку и содержит "привет"
...
```
Здесь использованы _«Magic filters»_ через объект F – они позволяют строить условия, проверяющие поля объекта сообщения (подробнее о F-выражениях ниже).
**Приоритет обработки:** Если нужно, чтобы один обработчик отработал вместо другого, можно зарегистрировать более специфичный фильтр _раньше_. Также возможна регистрация нескольких декораторов для одной функции, чтобы она реагировала на разные условия (это эквивалент логического ИЛИ – каждый декоратор регистрирует хендлер отдельно) :
```
@dp.message(Command("hello"))
@dp.message(Command("hi"))
async def greet(message: Message):
await message.answer("Здравствуйте!")
```
Теперь хендлер greet выполнится при вводе /hello или /hi. Можно добиться того же, вызвав dp.message() дважды с разными фильтрами или используя RegExp в фильтре команды.
Помимо команд, есть встроенные фильтры для содержания текста, типа чата, типа контента (текст, фото, стикер и др.), упоминания бота и т.д. Часто используемый фильтр – Text, который позволяет отфильтровать сообщения по равенству/вхождению текста. Например, Text(equals="да") для сообщений, ровно равных “да”.
### **Обработчики нажатий кнопок (callback_query)**
Когда пользователь нажимает кнопку **InlineKeyboardButton** с параметром callback_data, бот получает событие типа **CallbackQuery**. Чтобы обработать нажатие, регистрируется обработчик через декоратор @router.callback_query(...). Чаще всего нужно фильтровать по содержимому callback_data, чтобы понять, какую именно кнопку нажали.
Простейший вариант – отфильтровать по конкретному значению данных. Например, если в кнопке вы передали callback_data="btn1", можно ловить так:
```
from aiogram import F
@dp.callback_query(F.data == "btn1")
async def on_btn1_press(callback: types.CallbackQuery):
await callback.message.answer("Вы нажали кнопку 1!")
await callback.answer()# ответ на callback (убирает "часики")
```
Здесь используется F.data – он ссылается на поле callback_query.data и сравнивается с строкой. Когда эта кнопка нажата, бот отправит подтверждение в чат. Метод callback.answer() отправляет служебный ответ Telegram, что запрос обработан (можно передать текст или alert, но в данном случае он вызывается без параметров просто чтобы убрать индикатор загрузки на кнопке).
Однако, **жёстко прописывать строковые идентификаторы** не всегда удобно, особенно когда много разных кнопок. Aiogram предлагает механизм **CallbackData** для структурирования данных колбэка. С помощью класса CallbackData можно задать шаблон данных и легко парсить их.
Например, определим шаблон с именем и числовым параметром:
```
from aiogram.filters.callback_data import CallbackData
class MyCallback(CallbackData, prefix="my"):
foo: str
bar: int
```
Здесь мы создали класс, наследующий CallbackData, задав префикс "my" и два поля: строковое foo и целочисленное bar. Префикс нужен, чтобы отличать колбэки этого типа от других (он станет началом строки данных). После этого можно генерировать данные:
```
cb = MyCallback(foo="demo", bar=42)
data_str = cb.pack()# вернёт строку "my:demo:42"
```
Метод pack() сериализует объект в строку для callback_data. Метод unpack() делает обратно – из строки возвращает объект MyCallback. При использовании в коде обычно достаточно вызывать pack().
**Как использовать с кнопками:**
```
button = types.InlineKeyboardButton(
text="Demo",
callback_data=MyCallback(foo="demo", bar=42).pack()
)
keyboard = types.InlineKeyboardMarkup(inline_keyboard=[[button]])
```
Теперь при нажатии этой кнопки боту придёт callback_data вида "my:demo:42". Мы можем зарегистрировать обработчик с фильтром по нашему классу:
```
@dp.callback_query(MyCallback.filter(F.foo == "demo"))
async def handle_demo_btn(callback: types.CallbackQuery, callback_data: MyCallback):
# Этот хендлер сработает для колбэков типа MyCallback, у которых foo == "demo"
await callback.answer("Обработан callback с foo=demo")
# В переменную callback_data передан распарсенный объект MyCallback
print("bar =", callback_data.bar)# доступ к числовому полю bar
```
Обратите внимание: мы используем MyCallback.filter(...) для фильтрации . Метод filter класса CallbackData возвращает фильтр (объект типа CallbackQueryFilter), который проверяет, что колбэк соответствует структуре MyCallback и условию F.foo == "demo". В сигнатуре обработчика мы указали второй аргумент callback_data: MyCallback – aiogram автоматически распарсит данные и передаст объект MyCallback с заполненными полями . Благодаря этому, внутри функции удобно работать с callback_data.bar и другими полями, вместо ручного разбора строки.
Можно не ограничиваться одним значением – фильтр может проверять сразу несколько полей. Также, если нужно отловить _любое_ значение, достаточно указать фильтр без условий: @router.callback_query(MyCallback.filter()) – обработчик поймает все колбэки, соответствующие шаблону MyCallback (с любыми foo и bar).
**Пример:** Представьте, что у админа есть кнопки для действий над пользователем: Ban, Kick, Warn. Можно определить перечисление и CallbackData:
```
from enum import Enum
class Action(str, Enum):
ban = "ban"
kick = "kick"
warn = "warn"
class AdminAction(CallbackData, prefix="adm"):
action: Action
chat_id: int
user_id: int
```
При генерации кнопок укажем разные action:
```
for action in Action:
keyboard.add( types.InlineKeyboardButton(
text=action.value.title(),
callback_data=AdminAction(action=action, chat_id=chat_id, user_id=user_id)
))
```
Aiogram распознает, что callback_data – это объект AdminAction и сам вызовет pack() при отправке сообщения (если используете **KeyboardBuilder**, он делает это автоматически ). В обработчике можно фильтровать, например, только на действие бана:
```
@dp.callback_query(AdminAction.filter(F.action == Action.ban))
async def on_ban_button(callback: types.CallbackQuery, callback_data: AdminAction):
# Используем Bot для выполнения действия бана
await callback.answer("Пользователь забанен.")
await bot.ban_chat_member(chat_id=callback_data.chat_id, user_id=callback_data.user_id)
```
Таким образом, **CallbackData** позволяет надежно кодировать параметры в callback_data и легко их декодировать в обработчике, избегая ошибок при ручной конкатенации строк.
После обработки callback-запроса **не забудьте ответить на него** методом callback_query.answer(). Если ответ не нужен (как в примере выше, где мы отдельно отправляем сообщение), достаточно вызвать await callback.answer() без параметров – это закроет всплывающее “часиков” у пользователя.
### **Обработчики инлайн-режима (inline_query)**
**Инлайн-режим** бота позволяет пользователям вводить имя бота и запрос прямо в поле ввода любого чата, а бот возвращает набор результатов. Если бот поддерживает inline, при вводе @ботникнейм запрос Telegram пришлёт боту событие **InlineQuery**.
Чтобы обработать инлайн-запрос, зарегистрируйте хендлер через декоратор @router.inline_query() (или dp.inline_query()). Например:
```
@dp.inline_query()
async def handle_inline_query(inline_query: types.InlineQuery):
query_text = inline_query.query# текст запроса после @botname
results = []
# Формируем список результатов, например, один Article
results.append(types.InlineQueryResultArticle(
id="1",
title="Эхо",
description="Отправить ваш текст обратно",
input_message_content=types.InputTextMessageContent(
message_text=query_text or "Эхо-пусто"
)
))
# Отправляем результаты
await inline_query.answer(results, cache_time=5)
```
Здесь мы без фильтра ловим _все_ инлайн-запросы. Через inline_query.query можно получить строку запроса. Мы формируем список results (не более 50 элементов) из объектов InlineQueryResult... (статья, фото, гиф и т.д.). В примере добавлен один результат типа Article, который при выборе отправит в чат введённый пользователем текст (если текст пустой – отправится строка “Эхо-пусто”). Метод inline_query.answer(results, cache_time=5) отправляет эти результаты пользователю . Параметр cache_time указывает время (в секундах), на которое результат будет кэшироваться для данного пользователя.
**Фильтрация инлайн-запросов:** Вы можете использовать фильтры F.query для условий. Например, чтобы различать разные команды inline, пользователь может вводить определённые ключевые слова. Можно зарегистрировать несколько хендлеров:
```
@dp.inline_query(F.query == "sticker")
async def inline_sticker(inline_query: InlineQuery):
# вернуть список результатов стикеров...
@dp.inline_query(F.query.startswith("weather "))
async def inline_weather(inline_query: InlineQuery):
# вернуть прогноз погоды...
```
Если ни один из более специфичных фильтров не подошёл, может сработать общий хендлер (как handle_inline_query выше) с пустым условием, который отдаст дефолтные или пустые результаты.
Чтобы бот поддерживал inline-режим, **не забудьте включить его у BotFather** командой /setinline. Также можно задать placeholder (подсказку) для ввода.
### **Обработчики выбранного результата (chosen_inline_result)**
Связанное событие – **ChosenInlineResult**, когда пользователь выбирает один из предложенных инлайн-результатов. Этот апдейт может быть полезен для отслеживания факта выбора (например, чтобы вести статистику). В aiogram 3.x есть декоратор @router.chosen_inline_result() или класс ChosenInlineResultHandler. Использование похоже на inline_query, но без возможности ответить (бот просто получает уведомление).
Пример регистрации:
```
@dp.chosen_inline_result()
async def on_chosen_inline(result: types.ChosenInlineResult):
user_id = result.from_user.id
query = result.query
result_id = result.result_id
print(f"Пользователь {user_id} выбрал результат {result_id} по запросу '{query}'.")
```
Здесь мы просто логируем информацию. Обработчик _должен быть быстрым_ и не выполняет взаимодействия с пользователем (в ответ ничего не отправляется).
### **Обработка прочих типов обновлений**
Aiogram поддерживает обработчики для **любых** типов событий, доступных в Telegram Bot API. Выше мы рассмотрели основные: сообщения, колбэки, инлайн-запросы. Помимо них, существуют:
- **Обработчики событий чата**: например, ChatMemberUpdated (вход/выход участника, изменения статуса), регистрируется декоратором @router.chat_member() или используется фильтр ChatMemberUpdated() .
- **Обработчики сервисных обновлений**: MyChatMember, ChatJoinRequest и др. – есть соответствующие фильтры/декораторы.
- **Обработчики запросов оплаты**: PreCheckoutQuery (последний шаг перед подтверждением оплаты), ShippingQuery (запрос адреса доставки) – декораторы @router.pre_checkout_query() и @router.shipping_query().
- **Обработчики событий опросов**: Poll и PollAnswer – декораторы @router.poll() и @router.poll_answer().
- **Обработчик команд из меню бота** (команды, заданные через BotFather) можно обрабатывать как обычные команды (они тоже приходят как сообщения с entities.type == bot_command).
Полный перечень типов обновлений см. в документации Telegram (и перечисление aiogram.enums.UpdateType). В aiogram 3.x на каждый тип, как правило, можно навесить хендлер. Если же какой-то специфический тип требуется обработать вручную, можно зарегистрировать базовый хендлер @dp.update() – он получит все необработанные обновления.
### **Обработчики ошибок**
Ошибка может произойти внутри хендлера (например, не удалось обработать входные данные) или при вызове Telegram API (например, бот потерял права на отправку в чат). Aiogram предоставляет несколько способов обработать исключения:
1. **Локальный try-except в обработчике.** Рекомендуется ловить ожидаемые ошибки прямо в том месте, где они могут произойти . Например, если вы вызываете bot.send_message и он может выбросить TelegramForbiddenError (бот заблокирован пользователем), можно обернуть в try/except TelegramForbiddenError и выполнить альтернативные действия (не отправлять сообщение, сохранить статус и т.п.).
2. **Глобальные обработчики ошибок.** Вы можете зарегистрировать специальный **error handler** на уровне Router или Dispatcher. Такой обработчик перехватит исключение, “поднятое” из любого хендлера в данном Router/Dispatcher.
Чтобы объявить обработчик ошибок, используется декоратор @router.error() (или @dp.error() соответственно). В него можно также передать фильтр по типу исключения.
**Пример:**
```
import logging
from aiogram.filters import ExceptionTypeFilter
from aiogram.types import ErrorEvent
@router.error(ExceptionTypeFilter(MyCustomError))
async def handle_custom_error(event: ErrorEvent):
# Обработка специфического исключения MyCustomError
await event.update.message.answer("Произошла известная ошибка, попробуйте позже.")
```
```
@router.error()
async def handle_all_errors(event: ErrorEvent):
# Общий обработчик на все непойманные ошибки
logging.exception(f"Unhandled error: {event.exception}")
# Допустим, оповестим админа о критической ошибке
```
В первой функции применён фильтр ExceptionTypeFilter(MyCustomError), поэтому она перехватит только наше исключение MyCustomError, если оно возникло в процессе обработки обновления. Во второй функции фильтров не указано – она поймает любые исключения, не обработанные ранее . Объект event типа ErrorEvent содержит поле event.update (то обновление, при обработке которого произошла ошибка) и event.exception (сам выброшенный Exception) .
**Приоритет:** Error handler, привязанный к конкретному Router, будет обрабатывать ошибки только для обработчиков внутри этого Router . Error handler, заданный на Dispatcher, действует глобально на все роутеры (если ошибка не перехвачена на уровне ниже) .
**Примечание:** Не все исключения стоит обрабатывать глобально – зачастую лучше явно предусмотреть их внутри логики. Но глобальный обработчик полезен для непредвиденных ситуаций, чтобы хотя бы залогировать их и предотвратить «падение» бота.
Aiogram определяет базовый класс исключений AiogramError и ряд подклассов для различных ошибок API – например, TelegramBadRequest (ошибка 400, неправильный запрос), TelegramForbiddenError (403, бот не имеет права), TelegramNetworkError (ошибки сети) и др. Вы можете в ExceptionTypeFilter указывать эти классы, чтобы выборочно обрабатывать, например, блокировку бота (Forbidden) или превышение лимитов (RetryAfter).
### **Логирование**
Для отладки и мониторинга работы бота важно настроить логирование. В примерах обычно используется стандартный модуль Python logging. Например, в начале программы можно инициализировать:
```
import logging
logging.basicConfig(level=logging.INFO)
```
Так вы будете видеть в консоли основные события (aiogram выводит информацию о запуске, о получении обновлений и т.д. на уровне INFO). Для дополнительной информации можете установить уровень DEBUG, тогда aiogram будет логировать и запросы/ответы к Telegram API.
В своих обработчиках и функциях используйте logging.warning(), logging.error() и другие методы для записи важных событий (например, попытка использования команды без прав, ошибка бизнес-логики и т.п.).
Глобальные обработчики ошибок, как показано выше, также могут использовать logging.exception() чтобы вывести стек-трейс исключения для диагностики.
## **Фильтры: встроенные и кастомные**
**Фильтры** – это условия, определяющие, должен ли данный обработчик быть вызван для конкретного обновления. Мы уже видели примеры фильтров: Command("start"), F.text.contains("hi") и т.д. Aiogram обладает мощной системой фильтрации.
Основные особенности фильтров в aiogram 3.x:
- Фильтр может быть передан в декоратор при регистрации хендлера (как позиционный аргумент).
- Можно указать несколько фильтров через запятую – тогда они объединяются по логическому И (все должны вернуть True) .
- Если нужно реализовать логику ИЛИ, регистрируйте несколько обработчиков с разными фильтрами (или используйте кастомный фильтр, объединяющий логику).
- Если ни один фильтр обработчика _не проходит_, обработчик пропускается, и Dispatcher ищет следующий подходящий хендлер .
### **Встроенные фильтры**
Aiogram предлагает ряд готовых фильтров (модуль aiogram.filters):
- **Command / CommandStart / CommandObject** – фильтры для команд (с слешем). Command("name") проверяет команду, CommandStart() фильтрует команду /start (включая параметры /start payload), а Command(commands, ignore_case) – универсальный.
- **Text** – фильтр по содержимому текста сообщения (равенство, содержимость, начинается/заканчивается, регистрозависимость).
- **ContentTypes / ContentTypeFilter** – фильтр по типу содержимого (текст, фото, видео, документ и т.д.).
- **ChatTypeFilter** – фильтр по типу чата (приватный, группа, супергруппа, канал).
- **UserFilter / ChatFilter** – фильтры по конкретному ID пользователя или чата (например, чтобы ограничить команду только админом).
- **StateFilter** – фильтр по состоянию FSM (матчится, если у пользователя установлено определённое состояние; обычно указывается автоматически, когда в декоратор передаётся объект State, см. FSM ниже).
- **ExceptionTypeFilter** – фильтр по типу исключения (для error handler’ов, рассмотрен ранее).
- **CallbackDataFilter** – фильтр по данным колбэка (не используется напрямую, вместо него удобнее CallbackData.filter() как мы делали).
- **MagicFilter (F)** – особый тип фильтра, о нём отдельно ниже.
Для событий, отличных от сообщений, есть свои: CallbackQueryFilter, InlineQueryFilter, ChatMemberUpdatedFilter и т.д., однако вы редко используете их напрямую – aiogram сам применяет нужный фильтр, когда вы пишете условия через F или CallbackData.filter().
**Magic filters (объект F):** aiogram интегрирует библиотеку [magic-filter](https://github.com/aiogram/magic-filter) . Импортируя from aiogram import F, вы получаете специальный объект, который перегружает операторы сравнения для построения условий. Мы использовали его в примерах: F.text == "hello", F.text.casefold() == "yes", F.chat.type == "private", F.text.func(len) <= 30 и т.п. Такие выражения превращаются в фильтр, который aiogram применяет к обновлению. Magic-filter позволяет обращаться к атрибутам объекта обновления (и вложенных объектов) и применять функции (.lower(), .len() и даже .func(custom_func) для произвольных функций) . Это делает фильтры очень выразительными без написания собственного класса. Например:
```
# Сообщение с фото (PhotoSize) и его ширина больше 1000 пикселей
@dp.message(F.photo[-1].width >= 1000)
async def on_large_photo(message: Message):
await message.reply("Ух ты, большое фото!")
```
В выражении F.photo[-1].width >= 1000 мы проверяем последний объект PhotoSize в списке фотографий сообщения и сравниваем его ширину с 1000. Magic-filter отработает только если у Message есть photo (иначе фильтр вернёт False и хендлер пропустится), затем извлечёт ширину и сделает сравнение.
### **Кастомные фильтры**
Если встроенных фильтров недостаточно, вы можете определить свои. Aiogram позволяет использовать в качестве фильтра:
- Асинхронную или синхронную функцию, возвращающую bool или dict .
- Любой awaitable объект (корутина) – он будет выполнен, и её результат трактуется как выше.
- Класс, наследующий aiogram.filters.base.Filter с определённым методом __call__ .
- Лямбда-функцию (для простых одноразовых условий).
- Экземпляр MagicFilter (то есть выражение F, уже рассмотрено).
Возврат фильтра: **Если фильтр возвращает False**, обработчик не выполняется. **Если возвращает True**, обработка продолжается. **Если возвращается dict**, то его содержимое добавляется как именованные аргументы в последующий фильтр(ы) и в сам обработчик . Этот механизм позволяет фильтру передать в хендлер дополнительные данные. Например, можно написать фильтр, который извлекает из текста URL и возвращает {"url": "<найденный URL>"} – тогда в обработчике можно добавить параметр url, и aiogram автоматически передаст туда значение.
**Пример собственного фильтра (классом):**
```
from aiogram.filters import Filter
from aiogram.types import Message
class HasLink(Filter):
async def __call__(self, message: Message) -> bool:
# простой поиск ссылки в тексте
return bool(message.entities) and any(ent.type == "url" for ent in message.entities)
```
Регистрируем его:
```
@dp.message(HasLink())
async def on_message_with_link(message: Message):
await message.answer("Вы отправили ссылку!")
```
Этот фильтр HasLink проверяет, есть ли в сообщении хотя бы одна сущность типа URL. Он возвращает True или False. При True выполнится хендлер, при False – нет.
**Пример фильтра, возвращающего данные:**
```
class ExtractLink(Filter):
async def __call__(self, message: Message) -> dict:
for ent in message.entities or []:
if ent.type == "url":
url = message.text[ent.offset: ent.offset + ent.length]
return {"url": url}
return False
```
Этот фильтр ищет первую URL-ссылку и возвращает словарь с ключом "url". Если ссылки нет – возвращает False (не пройдет фильтр). Использование:
```
@dp.message(ExtractLink())
async def handle_link(message: Message, url: str):
await message.answer(f"Вы прислали ссылку: {url}")
```
При срабатывании обработчика aiogram возьмет значение url из словаря фильтра и передаст его как аргумент url в функцию . Такой подход упрощает обработчики – всю логику извлечения нужных данных можно инкапсулировать в фильтре.
**Регистрация глобальных фильтров:** В aiogram 3.x появилась возможность добавить фильтр ко всему Router. Например, вы хотите, чтобы все хендлеры внутри определенного Router обрабатывали только сообщения из приватных чатов – можно при создании роутера указать router.message.filter(F.chat.type == "private") один раз, и он будет применяться ко всем хендлерам сообщений этого роутера. Аналогично router.callback_query.filter(...) и др. Это удобнее, чем дублировать один и тот же фильтр во всех декораторах. Глобальный фильтр можно добавить и через include_router: если родительскому Router при подключении дочернего передать include_router(child, exclude_event_types=[...]), но про это подробности в официальной документации.
**Комбинирование фильтров:** Ранее уже отмечалось – несколько фильтров в декораторе означает логическое И . Если нужно объединить по ИЛИ, регистрируйте несколько декораторов (как с командами /hello и /hi) или пишите кастомный фильтр, возвращающий True при разных условиях. Например, простейший способ – использовать Python логическое сложение внутри __call__:
```
class IsHi(Filter):
async def __call__(self, msg: Message) -> bool:
text = msg.text.lower() if msg.text else ""
return text == "привет" or text == "здравствуйте"
```
Такой фильтр вернет True для двух вариантов текста.
## **Finite State Machine (FSM) – конечные автоматы состояний**
Для реализации пошаговых сценариев (опросов, анкет, многошаговых диалогов) aiogram предоставляет встроенный механизм **FSM**. С его помощью бот может «запоминать», на каком этапе разговора находится тот или иной пользователь, и маршрутизировать сообщения в соответствующие обработчики состояний.
### **Понятие состояния**
Состояние – это метка, отражающая текущее положение пользователя в сценарии. Пользователь может находиться в одном состоянии из некоторого набора, или не находиться ни в каком (состояние по умолчанию). FSM можно представить как граф: узлы – состояния, а переходы – то, как мы перемещаемся между ними в ответ на сообщения пользователя .
**Когда нужен FSM?** Если логику нельзя реализовать одним обработчиком (например, нужно последовательно задать несколько вопросов и получить несколько ответов), применяйте FSM . Без FSM бот не сможет отличить, к какому шагу относится введённый пользователем текст. С FSM же каждое последующее сообщение можно направить в свой хендлер, привязанный к состоянию.
### **Определение группы состояний**
Начнём с объявления **группы состояний**. Создайте класс, наследуя StatesGroup, и перечислите атрибуты-классы типа State:
```
from aiogram.fsm.state import StatesGroup, State
class OrderForm(StatesGroup):
waiting_for_name = State()
waiting_for_address = State()
```
Здесь OrderForm – группа состояний оформления заказа с двумя шагами: ожидание имени и ожидание адреса. Атрибуты waiting_for_name и waiting_for_address автоматически станут экземплярами State. Вы можете иметь множество групп состояний для разных сценариев, но внутри одной группы имена должны быть уникальны.
### **Начало сценария и переходы**
Чтобы запустить сценарий, обычно используется какой-то триггер, например команда. Обработчик этой команды переводит пользователя из начального состояния (None) в первое состояние сценария:
```
from aiogram.fsm.context import FSMContext
from aiogram.filters import Command
@dp.message(Command("start_order"))
async def start_order(message: Message, state: FSMContext):
await message.answer("Начнём оформление заказа. Как вас зовут?")
await state.set_state(OrderForm.waiting_for_name)# переход в состояние
```
Здесь мы получили объект FSMContext через параметр state в функции. Aiogram предоставляет FSMContext для взаимодействия с хранилищем состояний и данных. Метод set_state(State) устанавливает пользователю новое состояние . Теперь все последующие сообщения от этого пользователя будут автоматически направляться в обработчики, которые **ожидают это состояние**.
Как ожидать состояние? В декораторе обработчика вместо фильтра можно указать объект состояния или весь класс StatesGroup. Например, чтобы обработать ввод имени в состоянии waiting_for_name:
```
@dp.message(OrderForm.waiting_for_name)
async def get_name(message: Message, state: FSMContext):
name = message.text
# Сохраняем имя во временное хранилище FSM
await state.update_data(name=name)
await message.answer(f"Спасибо, {name}! Теперь укажите адрес доставки.")
await state.set_state(OrderForm.waiting_for_address)
```
Этот хендлер сработает только на сообщения от пользователей, которые находятся в состоянии OrderForm.waiting_for_name. Мы сохранили введённое имя во внутреннем **словаре данных** FSM (через update_data) и перевели состояние на следующий шаг waiting_for_address .
Следующий обработчик адреса будет ожидать OrderForm.waiting_for_address:
```
@dp.message(OrderForm.waiting_for_address)
async def get_address(message: Message, state: FSMContext):
data = await state.get_data()# достаём накопленные данные
name = data.get("name")
address = message.text
# Здесь можно, например, сохранить заказ в базу данных
await message.answer(f"Спасибо, {name}! Ваш заказ будет доставлен по адресу: {address}.")
await state.clear()# сбрасываем состояние (диалог завершён)
```
Мы получили сохранённое имя из хранилища, обработали адрес и завершаем сценарий. Метод state.clear() сбрасывает состояние и очищает данные . Теперь пользователь вернулся в нейтральное состояние (None), и его следующие сообщения не будут идти в обработчики этого сценария.
### **Хранение данных и хранилища**
FSM предоставляет **хранилище данных** – некий словарь, где можно сохранять информацию между шагами диалога. В примере выше мы сохраняли имя. FSMContext имеет методы:
- await state.update_data(key=value) – добавить/обновить запись.
- await state.get_data() – получить весь словарь данных.
- await state.set_data({...}) – установить весь словарь данных (реже используется).
- await state.clear() – сбросить состояние **и** стереть данные.
По умолчанию aiogram использует **MemoryStorage** – хранилище в памяти, т.е. данные FSM хранятся в оперативной памяти и сбрасываются при перезапуске бота. Это подходит для небольших ботов или непродолжительных диалогов. Если нужно сохранять состояния между запусками или горизонтально масштабировать бота, используйте внешние хранилища:
- **MemoryStorage** – хранит в памяти (volatile). По умолчанию инициализируется автоматически, если вы не указали другое хранилище при запуске polling.
- **RedisStorage** – хранит состояния в Redis (требуется установка доп. пакета aiogram-redis, обычно).
- **MongoStorage** – хранит в MongoDB.
- **SQLStorage** и другие – возможно, существуют реализации или вы можете написать своё, реализовав интерфейс BaseStorage.
Чтобы использовать, например, RedisStorage, нужно установить redis-библиотеку, затем:
```
from aiogram.fsm.storage.redis import RedisStorage
storage = RedisStorage.from_url("redis://localhost:6379")
dp = Dispatcher(storage=storage)
```
И затем dp.start_polling(bot) как обычно. Aiogram будет сохранять состояния/данные пользователей в Redis.
MemoryStorage и другие готовые хранилища перечислены в документации . При использовании FSMContext, aiogram сам берёт текущее хранилище из диспетчера. Также, если нужно вручную очистить или изменить данные, можно получить объект хранилища через dp.storage.
По умолчанию **стратегия** ключей FSM – “user in chat”. То есть состояние уникально для комбинации (user_id, chat_id). Это логично: один и тот же пользователь может отдельно иметь состояния в разных чатах (например, в групповом и в личке). Можно изменить стратегию, например, на “только по пользователю глобально” или “по чат-топику” (для форумов), используя FSMStrategy при инициализации Dispatcher . Но обычно стандартного поведения достаточно.
### **Пример сценария с выбором вариантов**
Рассмотрим чуть более сложный пример FSM, используя ветвление. Допустим, бот спрашивает: любит ли пользователь писать ботов, и в зависимости от ответа переходит к разным шагам.
```
from aiogram import F, html
from aiogram.types import KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove
class Survey(StatesGroup):
like_bots = State()
language = State()
@dp.message(Command("survey_start"))
async def survey_start(message: Message, state: FSMContext):
await message.answer("Ты любишь писать ботов?", 
 reply_markup=ReplyKeyboardMarkup(
 keyboard=[[KeyboardButton(text="Да"), KeyboardButton(text="Нет")]],
 resize_keyboard=True))
await state.set_state(Survey.like_bots)
```
Это начало опроса: задаём вопрос и показываем **Reply-клавиатуру** с вариантами “Да”/“Нет”. Переводим состояние в Survey.like_bots. Далее два обработчика на это состояние, с разными фильтрами для ответа “Да” и “Нет”:
```
@dp.message(Survey.like_bots, F.text.casefold() == "да")
async def answer_yes(message: Message, state: FSMContext):
await message.reply("Отлично! Какой язык программирования тебе нравится?", 
reply_markup=ReplyKeyboardRemove())
await state.set_state(Survey.language)
@dp.message(Survey.like_bots, F.text.casefold() == "нет")
async def answer_no(message: Message, state: FSMContext):
await message.answer("Жаль... Завершаем опрос.", reply_markup=ReplyKeyboardRemove())
await state.clear()
# Возможно, логика для случая "нет" – сразу конец сценария
```
В первом хендлере (ответ “Да”) мы задаём следующий вопрос о языке программирования, убирая клавиатуру (ReplyKeyboardRemove()) и переводим состояние на Survey.language. Во втором (ответ “Нет”) – завершаем опрос: отправляем сообщение, убираем клавиатуру и сбрасываем состояние (т.е. выходим из сценария).
Наконец, обработчик для состояния Survey.language – он получит любой текст (название языка):
```
@dp.message(Survey.language)
async def answer_language(message: Message, state: FSMContext):
lang = message.text.strip()
await message.answer(f"Спасибо за ответы! Я тоже люблю {lang}.")
await state.clear()
```
После получения ответа сценарий завершается.
Этот пример показал: **FSM** позволяет не только линейные диалоги, но и разветвление по условиям. Мы использовали фильтр F.text.casefold() == "да" для нестрогого сравнения, чтобы учесть разный регистр ответа пользователя (приводим к нижнему регистру) .
### **Возможность отмены и таймауты**
В сценариях желательно иметь команду отмены, чтобы пользователь мог прервать диалог. Часто используют команду /cancel. Сделать это легко:
```
@dp.message(Command("cancel"))
@dp.message(F.text.lower() == "cancel")
async def cancel_action(message: Message, state: FSMContext):
current_state = await state.get_state()
if current_state is None:
return# ничего не делаем, если пользователь не в состоянии
await state.clear()
await message.answer("Действие отменено.", reply_markup=ReplyKeyboardRemove())
```
Этот хендлер можно зарегистрировать глобально (без указания конкретного состояния) – тогда он поймает /cancel на любом этапе и выйдет из текущего FSM-сценария . Мы также реагируем на текст “cancel” на случай, если пользователь вводит отмену не командой, а просто словом.
По умолчанию FSM не реализует автоматических таймаутов для состояний. Если нужно сбрасывать состояние через некоторое время неактивности, придётся самостоятельно реализовать фоновые задачи или использовать планировщик (см. **Фоновые задачи** ниже) для мониторинга. Либо можно в state.set_state(..., state=..., timeout=seconds) указать таймаут, но на момент 3.x документация не указывает встроенного параметра timeout (возможно, появится или нужно реализовать через middleware).
### **Scenes (Wizards)**
Aiogram 3.x также предлагает более высокоуровневый абстрактный механизм под названием **Scenes** – это надстройка над FSM, облегчающая создание многошаговых диалогов (Wizard). В сценах вы описываете последовательность шагов с помощью специализированных классов. Рассмотрение Scenes Wizard выходит за рамки нашего обзора, но вкратце: вы можете создавать объекты Scene с набором шагов, слушателей (enter/exit events), и регистрировать эти сцены на Router. Scenes могут быть удобны, если у вас много пересекающихся сценариев и требуется гибкость (например, возможность перехода назад, повтор шага, условный переход и т.д.) . Однако для большинства задач достаточно использовать FSM как описано выше.
## **Middleware – промежуточная обработка**
**Middleware (промежуточное ПО)** – это функции или классы, которые выполняются _до_ и/или _после_ основного обработчика, перехватывая процесс обработки обновления. С их помощью можно изменить или дополнить данные запроса, отменить выполнение обработчика, выполнить какие-то общие действия (логирование, замеры времени, прелоад данных из БД и т.п.) .
Aiogram поддерживает два уровня middleware для входящих обновлений:
1. **Outer middleware** – внешний уровень: выполняется _до применения фильтров_, сразу после получения Update .
2. **Inner middleware** – внутренний уровень: выполняется _после прохождения фильтров, но перед вызовом обработчика_ .
Также есть middleware для исходящих запросов (к Bot API) – их можно использовать, чтобы, например, логировать все отправляемые ботом сообщения или менять параметры запросов. Они настраиваются через ClientSession (см. документацию, раздел **Client session middlewares**), но здесь сосредоточимся на входящих.
**Подключение middleware:** Чтобы задействовать middleware, нужно его зарегистрировать. Методы регистрации:
- Глобально на **Dispatcher**: dp.update.outer_middleware(mw_instance) или dp.update.middleware(mw_instance) – применится ко всем типам событий.
- На конкретный **Router**: аналогично router.update.outer_middleware(...) или на конкретный тип: router.message.middleware(...) – применится только к событиям сообщений в данном роутере.
- Декоратором: @dp.update.outer_middleware() над функцией – регистрирует функцию как внешнее мидлваре .
Обратите внимание: outer_middleware применяется один раз на самый верхний Update (например, входящий апдейт), а middleware на уровень конкретного события внутри (например, Message). Как отмечено выше, **inner middleware для Update вызывается всегда**, потому что Update всегда “проходит” в обработчик (который разветвляет на конкретный тип) . Но обычно вам нужно либо глобальное внешнее, либо внутреннее для конкретных типов.
**Создание middleware-класса:** Самый распространённый способ – написать класс, наследующий aiogram.BaseMiddleware . В нём нужно реализовать асинхронный метод __call__, который принимает handler, event и data .
- event – объект обновления (Message, CallbackQuery, etc.),
- data – словарь контекста (сюда можно добавлять данные, которые потом попадут в хендлер как аргументы),
- handler – сама функция обработчика, которую нужно вызвать, чтобы передать управление далее.
В __call__ вы можете выполнить нужные действия до и после вызова handler. **Важно:** чтобы не прерывать цепочку, нужно вызвать await handler(event, data) внутри вашего __call__ . Если же вы хотите **прервать обработку**, просто _не вызывайте_ handler – тогда ни следующие мидлвари, ни сам хендлер не выполнятся .
**Пример middleware – счётчик сообщений:**
```
from aiogram import BaseMiddleware
from aiogram.types import Message
class CounterMiddleware(BaseMiddleware):
def __init__(self):
self.counter = 0
async def __call__(self, handler, event: Message, data: dict):
self.counter += 1
data["counter"] = self.counter
return await handler(event, data)
```
Этот middleware подсчитывает количество обработанных сообщений и добавляет текущее значение счётчика в data под ключом "counter" . Затем вызывает handler, передавая управление следующему звену. В итоге, каждый обработчик сообщений сможет (если захочет) получить из контекста число сообщений, обработанных до сих пор.
Регистрация этого middleware на маршрутизатор сообщений:
```
router.message.middleware(CounterMiddleware())
```
После этого в любом обработчике сообщений можно указать параметр counter, и aiogram подставит туда значение из мидлвари:
```
@router.message()
async def any_message_handler(message: Message, counter: int):
print(f"Это сообщение номер {counter}")
...
```
Еще пример – **function-based middleware** (через декоратор). Можно оформить middleware как функцию с декоратором @dp.update.outer_middleware():
```
@dp.update.outer_middleware()
async def db_session_middleware(handler, event, data):
async with db.session():# открыть сессию БД
return await handler(event, data)
```
Таким образом, для каждого обновления будет автоматически открываться сессия к базе перед обработкой, и закрываться после (через контекстный менеджер) .
**Итоги и факты о middleware:**
- Мидлвари **outer** вызываются для каждого Update (например, один раз на поступившее обновление, даже если оно не пройдет фильтры) .
- Мидлвари **inner** вызываются только если событие прошло фильтры и будет передано обработчику .
- Middleware может быть асинхронным или синхронным (если сделать __call__ обычной функцией, aiogram тоже ее обработает, но лучше придерживаться async).
- **Никогда не забывайте вызвать await handler(...)**, если не хотите блокировать обработку .
- Middleware может менять event (например, подменить сообщение на другое) или добавлять информацию в data (как выше). Можно даже вызвать обработчик несколько раз или вовсе не вызывать – в зависимости от логики.
- Порядок подключения middleware важен: можно представить, что outer middleware А, потом B, потом inner C, D и т.д. – они образуют цепочку. Первым выполнится самый внешний (A), затем по цепочке до хендлера, а возвращаясь – может выполнение вернуться в A _после_ handler (если код написан после await handler). Т.е. можно обернуть вызов handler конструкцией try/except/finally для действий _после_ выполнения хендлера.
В заключение: используйте middleware для задач вроде **аутентификации/авторизации**, **логирования**, **изменения объектов события**, **глобального перехвата** (например, throttling – ограничение частоты сообщений, анти-спам) и других сквозных аспектов. У aiogram есть готовые middleware, например, **ThrottlingMiddleware** (ограничение частоты), **EnvironmentMiddleware** (для проброса глобальных переменных), а также middleware для отправки ChatAction (индикатора «набирает сообщение») , но их подключение нужно делать вручную.
## **Callback data и клавиатуры**
Современные боты активно используют клавиатуры – как **inline-клавиатуры** (встраиваемые под сообщением кнопки), так и **reply-клавиатуры** (которые заменяют собой поле ввода у пользователя). В aiogram есть инструменты для создания и обработки обоих видов клавиатур.
### **Reply-клавиатуры (ReplyKeyboardMarkup)**
Reply-клавиатура – это панель с кнопками, которая появляется в месте, где пользователь обычно вводит текст. Кнопки reply-клавиатуры при нажатии **отправляют заранее заданный текст** как обычное сообщение от пользователя. Такие клавиатуры удобно использовать для ограниченного набора ответов (например, кнопки “Да”/“Нет”, выбор из меню и т.п.).
Создание reply-клавиатуры:
```
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
keyboard = ReplyKeyboardMarkup(
keyboard=[
[KeyboardButton(text="Да"), KeyboardButton(text="Нет")],
],
resize_keyboard=True, # клавиатура подгоняется по высоте
one_time_keyboard=True# скрыть клавиатуру после нажатия (одноразовая)
)
await message.answer("Вам нравится бот?", reply_markup=keyboard)
```
Здесь мы создали клавиатуру с двумя кнопками в одном ряду. Параметр resize_keyboard делает кнопки менее громоздкими, one_time_keyboard – убирает клавиатуру после первого использования, чтобы не висела постоянно. Пользователь увидит кнопки “Да” и “Нет” и при нажатии на одну из них бот получит обычное сообщение “Да” или “Нет”. Далее это сообщение можно обработать нашим хендлером (в сочетании с FSM, как мы делали, или просто отдельным хендлером на текст).
Чтобы убрать reply-клавиатуру, отправьте новое сообщение с параметром reply_markup=ReplyKeyboardRemove() (специальный объект для удаления клавиатуры). Мы так делали в примерах FSM, когда переходили к следующему шагу.
Reply-клавиатура может содержать специальные кнопки: запрос контакта (KeyboardButton(request_contact=True)), запрос геолокации (request_location=True), запрос запроса от пользователя/чата (новые функциональности Telegram типа KeyboardButtonRequestUser). Они при нажатии выполняют особые действия (например, сразу отправляют контакт пользователя). Их разбор вне рамок данного обзора, но aiogram полностью поддерживает эти типы кнопок через класс KeyboardButton.
### **Inline-клавиатуры (InlineKeyboardMarkup)**
Inline-клавиатура – это кнопки под сообщением бота, которые привязаны именно к этому сообщению. Они не генерируют сообщения от пользователя, вместо этого при нажатии отправляется событие **CallbackQuery** боту. Такие кнопки подходят для создания меню, UI внутри чата, опросов, интерактивных списков и т.д. Также inline-кнопки могут открывать ссылки или запускать inline-режим (кнопка с switch_inline_query).
Создание inline-клавиатуры:
```
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
inline_kb = InlineKeyboardMarkup(inline_keyboard=[
[InlineKeyboardButton(text="Кнопка 1", callback_data="btn1")],
[InlineKeyboardButton(text="Открыть сайт", url="https://google.com")]
])
await message.answer("Выберите действие:", reply_markup=inline_kb)
```
Здесь первая кнопка при нажатии отправит боту callback_data "btn1" (который мы можем обработать, как показано ранее), а вторая – просто откроет ссылку в браузере (бот не получит уведомление о нажатии, так как url-кнопки обрабатываются на стороне клиента Telegram).
Часто inline-клавиатуры формируются динамически, например, список элементов с кнопками пагинации “Вперёд/Назад”, кнопки для голосования и пр. В таких случаях используют либо генерацию через списковые включения, либо **KeyboardBuilder** – вспомогательный утилитный класс в aiogram для поэтапного построения клавиатур.
**KeyboardBuilder:** Aiogram предоставляет класс InlineKeyboardBuilder (и аналогичный ReplyKeyboardBuilder) в aiogram.utils.keyboard. Он удобен, когда клавиатура зависит от условий. Пример использования:
```
from aiogram.utils.keyboard import InlineKeyboardBuilder
builder = InlineKeyboardBuilder()
for i in range(1, 6):
builder.button(text=f"№{i}", callback_data=f"number:{i}")
builder.button(text="Отмена", callback_data="cancel")
keyboard: InlineKeyboardMarkup = builder.as_markup()
```
В этом примере мы добавили 5 кнопок с номерами и одну кнопку отмены. builder.button() автоматически формирует ряды – по умолчанию все кнопки идут в один столбец. Можно управлять разметкой методами builder.adjust(...) (задаёт сколько кнопок в ряду, например builder.adjust(2,2,1) для 2+2+1) или builder.row() для явного разделения рядов.
**Использование с CallbackData:** Как видно из документации , builder.button умеет принимать в callback_data сразу объект класса CallbackData (например, MyCallback(foo="x", bar=1)) – он сам вызовет pack() при сборке as_markup(). Это значительно упрощает код, потому что можно не заботиться о серилизации строк вручную при построении больших клавиатур.
### **Обработка нажатий кнопок**
Обрабатывание inline-кнопок мы подробно разобрали в разделе про **callback_query**. Напомним ключевые моменты:
- Используйте @dp.callback_query(...) с нужными фильтрами (по данным, по пользователю, по состоянию, и т.д.).
- Не забывайте вызывать await callback.answer() для каждого нажатия, чтобы Telegram не отображал вращающийся индикатор бесконечно.
- Если по нажатию кнопки бот должен отредактировать сообщение или отправить новый – делайте это через методы Bot: await bot.edit_message_text(...) или проще через объект callback.message.edit_text(...) (aliased), или отправляйте новое сообщение обычным способом.
- Если нужно закрыть клавиатуру после нажатия, можно отредактировать сообщение, убрав у него клавиатуру (передав пустой reply_markup или вовсе другое сообщение без клавиатуры).
### **Пример интерактивного диалога с кнопками**
Для иллюстрации, объединим клавиатуры и FSM: например, бот задаёт вопрос с inline-кнопками “Да/Нет”, и в зависимости от ответа (который приходит как callback) переводит состояние или завершает. FSM можно запустить и callback’ом, т.к. FSMContext доступен и в обработчиках CallbackQuery.
```
class Quiz(StatesGroup):
confirmation = State()
@dp.message(Command("ask"))
async def ask_user(message: Message, state: FSMContext):
kb = InlineKeyboardMarkup(inline_keyboard=[[ 
InlineKeyboardButton(text="Да", callback_data="confirm:yes"),
InlineKeyboardButton(text="Нет", callback_data="confirm:no")
]])
await message.answer("Вы уверены?", reply_markup=kb)
await state.set_state(Quiz.confirmation)
@dp.callback_query(Quiz.confirmation, F.data == "confirm:yes")
async def on_confirm_yes(callback: CallbackQuery, state: FSMContext):
await callback.message.edit_text("Вы подтвердили действие.")# меняем текст вопроса, убирая клавиатуру
await callback.answer()
await state.clear()
@dp.callback_query(Quiz.confirmation, F.data == "confirm:no")
async def on_confirm_no(callback: CallbackQuery, state: FSMContext):
await callback.message.edit_text("Действие отменено пользователем.")
await callback.answer()
await state.clear()
```
В этом примере на команду /ask бот спрашивает “Вы уверены?” с двумя inline-кнопками. Устанавливаем состояние confirmation. Два обработчика callback_query ловят ответы “yes” и “no”. Оба находятся под состоянием Quiz.confirmation, поэтому не сработают раньше, чем состояние будет выставлено. При нажатии “Да” или “Нет”, мы редактируем исходное сообщение (edit_text убирает клавиатуру, потому что по умолчанию при редактировании, если не указать reply_markup, старая клавиатура исчезнет), отвечаем на callback (callback.answer()) и выходим из состояния.
Такое сочетание FSM + inline кнопки полезно, когда вопрос задан ботом и ответ должен прийти нажатием, а не текстом. Если бы не FSM, пришлось бы отслеживать, на что именно отвечает данный callback (например, по id сообщения). С FSM же можно однозначно понимать, какого действия ждет бот. Хотя в данном случае FSM, возможно, избыточен (можно было просто хранить ID сообщения или флаг в памяти), он демонстрирует подход.
## **Фоновые задачи (Background tasks)**
Иногда боту нужно выполнять фоновые действия независимо от входящих обновлений. Например, рассылать уведомления по расписанию, опрашивать внешние сервисы, обновлять кэш и т.п. Поскольку aiogram – асинхронный фреймворк, вы **не должны** использовать бесконечные циклы или блокирующие задержки в основном потоке – это остановит обработку обновлений. Вместо этого нужно запускать фоновые задачи.
### **asyncio.create_task**
Простейший способ – при старте бота создать задачу через asyncio.create_task. Например, хотим каждую минуту отправлять сообщение администратору:
```
import asyncio
async def notify_admin():
while True:
await asyncio.sleep(60)
await bot.send_message(admin_id, "Ещё одна минута прошла...")
```
Вместо вызова notify_admin() напрямую, запускаем задачу:
```
@dp.startup()# выполним на старте
async def on_startup():
asyncio.create_task(notify_admin())
```
Здесь мы воспользовались механизмом **стартап-события**: декоратор @dp.startup() регистрирует функцию, которая будет выполнена перед началом polling/webhook . В ней мы запускаем нашу фоновую задачу. asyncio.create_task планирует выполнение notify_admin() параллельно с основным loop. Таким образом, наш бесконечный цикл каждую минуту отправляет сообщение, не блокируя при этом приём обновлений (потому что это отдельная таска).
Aiogram 3.x позволяет привязать функции к событиям старта и остановки через Dispatcher.startup.register(coro) и Dispatcher.shutdown.register(coro) (или соответствующие декораторы). В примере мы использовали декоратор на dp.startup(), как было продемонстрировано в статье .
Если ваш фоновой процесс должен взаимодействовать с диспетчером (например, выполнять dp.feed_update или останавливать бот), убедитесь, что у вас есть доступ к нужным объектам.
### **Планировщики (Schedulers)**
Для более сложного расписания (например, каждую ночь в 2:00 или через определённое время) удобно применять библиотеку **APScheduler** или аналогичные. APScheduler хорошо работает в asyncio-среде с AsyncIOScheduler. Вы можете инициализировать планировщик и добавить задачи:
```
from apscheduler.schedulers.asyncio import AsyncIOScheduler
scheduler = AsyncIOScheduler()
async def scheduled_job():
await bot.send_message(admin_id, "Запланированное сообщение")
@dp.startup()
async def on_startup():
scheduler.add_job(scheduled_job, trigger="interval", hours=1)
scheduler.start()
```
В этом примере при старте мы настроили задачу scheduled_job с интервалом 1 час . APScheduler сам позаботится о вызове нашей coroutine по расписанию.
Aiogram не имеет встроенного планировщика, но легко интегрируется с APScheduler или другими, как видно.
### **Background tasks и Graceful Shutdown**
Если бот выполняет бесконечные фоновые циклы, корректная остановка бота (например, по сигналу SIGINT/SIGTERM) требует аккуратности. Aiogram 3.x обрабатывает сигнал завершения: при выходе из start_polling он вызовет коллбеки dp.shutdown (если зарегистрированы). В них можно, например, остановить планировщик: scheduler.shutdown() или отменить задачи.
Если у вас бесконечная while True: await sleep() задача, она не завершится сама. Можно в глобальной переменной завести флаг или использовать asyncio.Event для координации. Например, внутри цикла проверять if stop_event.is_set(): break. А в on_shutdown установить этот флаг. Либо сохранять объект задачи, чтобы потом отменить: task = asyncio.create_task(job()); ...; task.cancel().
### **Выполнение задач по командам пользователя**
Бывает, что нужно запустить долгую операцию по запросу (например, по команде пользователя), но не блокировать обработчик. В таком случае можно тоже использовать asyncio.create_task внутри хендлера:
```
@dp.message(Command("big_task"))
async def start_big_task(message: Message):
await message.answer("Задача запущена, я сообщу о результате.")
asyncio.create_task(run_big_task(message.chat.id))
```
Функция run_big_task(chat_id) может, например, долго что-то вычислять или обращаться к внешнему API, а по завершении отправить результат:
```
async def run_big_task(chat_id: int):
result = await long_calculation()
await bot.send_message(chat_id, f"Задача завершена, результат: {result}")
```
Мы сразу отвечаем пользователю, что задача началась, а саму тяжёлую работу запускаем в фоне. По её окончании бот отправит ещё одно сообщение с результатом. Так основной поток бота не задерживается на время вычислений.
Конечно, если функция long_calculation CPU-bound (тяжёлая вычислительно и синхронная), то await не поможет – она все равно блокирует поток Python. В таких случаях нужно выносить в отдельный ProcessPoolExecutor или иные средства, либо терпеть то, что на время расчёта бот подвиснет. Для IO-bound операций (сеть, диск) асинхронность работает отлично.
**Итог:** Возможности фоновых задач в aiogram ограничиваются возможностями Python async. Используйте asyncio.create_task для простых параллельных задач, и планировщики для сложных расписаний. И следите за тем, чтобы не создавать неуправляемых бесконечных задач, которые нельзя остановить – продумайте остановку при выключении бота.
## **Работа с Telegram API (отправка сообщений, фото и пр.)**
Aiogram максимально облегчает вызов методов Telegram Bot API. Как уже упоминалось, все методы доступны через объект Bot либо через контекстные алиасы (например, message.answer). Рассмотрим несколько типичных операций:
### **Отправка текстового сообщения**
```
await bot.send_message(chat_id=123456789, text="Привет от бота!")
```
Этот вызов отправит указанному чату текст. Как узнать chat_id? Он есть в каждом сообщении (message.chat.id), в callback запросе (callback_query.message.chat.id), и т.д. Обычно в ответах вы просто делаете await message.answer("..."), и aiogram сам подставит нужный chat_id .
Дополнительные параметры: метод send_message поддерживает Markdown или HTML разметку, клавиатуры (reply_markup), указание reply_to_message_id (ответ на конкретное сообщение), отключение веб-превью ссылок (disable_web_page_preview) и т.п. В aiogram они передаются как именованные параметры точно по спецификации Bot API. Например:
```
await message.answer(
"*Жирный текст* [ссылка](https://example.com)",
parse_mode="MarkdownV2",
disable_web_page_preview=True
)
```
Aiogram также предоставляет модуль aiogram.utils.markdown для упрощения экранирования символов и оформления Markdown-текста (например, функции bold(), italic(), link()), а также модуль aiogram.utils.html для HTML-форматирования (например, html.bold() используется в примерах ).
### **Отправка фото, документов, видео**
Отправка медиа файлов в Telegram API требует, чтобы вы передали либо файл, либо file_id (если файл уже был у бота) или URL. Aiogram содержит классы-обёртки для файлов:
- **FSInputFile** – для отправки файла из файловой системы .
- **BufferedInputFile** – для отправки из байтового объекта (например, изображение, сгенерированное Pillow) .
- **URLInputFile** – для отправки файла по URL через прокси своего бота (нужно, когда Telegram не может достать напрямую по URL из-за ограничений) .
Пример: отправим фотографию, которая лежит на диске:
```
from aiogram.types import FSInputFile
photo = FSInputFile("pictures/cat.png")
await message.answer_photo(photo, caption="Вот ваш котик")
```
Метод answer_photo – алиас к bot.send_photo, он сам определит chat_id и отправит. Мы передали объект FSInputFile. Aiogram за нас откроет файл и загрузит его. **Совет:** Telegram возвращает file_id после каждой отправки файла. Сохраните его (в базу или память), если планируете отправлять тот же файл снова. Так вы можете в следующий раз не загружать его, а использовать photo=file_id – Telegram пришлёт копию из своего кэша почти мгновенно .
Отправка документа или видео аналогична: используйте message.answer_document(FSInputFile("doc.pdf")), message.answer_video(FSInputFile("video.mp4")) и т.п. В параметрах можно указывать caption (подпись). Если нужно отправить **несколько фото как альбом**, есть метод send_media_group (и в aiogram утилита MediaGroupBuilder для удобного формирования списка медиа).
Если файл уже известен боту (есть file_id), просто:
```
await bot.send_photo(chat_id, photo="<file_id_from_previous_message>")
```
Aiogram распознает строку и отправит как file_id (Telegram не будет ожидать загрузки).
**Загрузка файлов пользователем:** Aiogram предоставляет метод message.photo[-1].download(destination) чтобы скачать файл, или можно использовать await bot.download_file(file_path, destination) получив file_path через await bot.get_file(file_id). Но в 3.x появился удобный механизм: у File есть методы download(). Подробнее – в документации (раздел **How to download file**).
### **Редактирование и удаление сообщений**
Inline-кнопки часто требуют редактирования сообщения бота. Aiogram позволяет редактировать текст, подпись, медиа, клавиатуры и пр.:
- await bot.edit_message_text(chat_id=..., message_id=..., text="Новый текст")
- await callback.message.edit_text("Новый текст") – алиас, автоматически подставляющий chat_id и message_id из callback.
- await message.edit_reply_markup(reply_markup=new_inline_kb) – если у вас объект Message (например, из callback.message), так можно обновить только клавиатуру, оставив текст.
- await bot.delete_message(chat_id, message_id) – удаление сообщения.
Обратите внимание: редактировать можно только **сообщения, отправленные ботом**. Сообщения пользователей бот редактировать или удалять не может (кроме удаление в группах, если бот админ с соответствующими правами).
### **Прочие методы**
Aiogram охватывает весь API Telegram Bot, включая:
- Управление чатом: kick_chat_member/ban_chat_member, unban_chat_member, restrict_chat_member, get_chat, get_chat_member, get_chat_administrators и др.
- Управление сообщениями: pin_chat_message, unpin_chat_message, edit_message_caption, edit_message_media.
- Работа с пользователями: get_user_profile_photos, send_chat_action (отображение “печатает…”).
- Интерактивность: send_poll (опросы), send_dice (рандомные эмодзи-игры), send_location, send_contact.
- Платежи: send_invoice, обработка PreCheckoutQuery и т.д.
- Установка меню бота, команд: set_my_commands – полезно вызывать в on_startup, чтобы у пользователя в интерфейсе отображались актуальные команды.
- Работа с файлами: upload_sticker_file, create_new_sticker_set, add_sticker_to_set для создания стикеров, create_chat_invite_link, approve_chat_join_request и многое другое.
Документация по всем методам доступна на сайте core.telegram.org и в разделах **Types** и **Methods** официальной документации aiogram. В aiogram методы представлены в двух формах:
1. **Методы Bot** – классические методы, принимающие параметры.
2. **Методы объектов** – например, у Message есть метод delete() – просто вызов await message.delete() сделает то же, что await bot.delete_message(message.chat.id, message.message_id).
Используйте тот вариант, который вам удобнее в контексте.
При вызове методов API нужно учитывать, что Telegram может возвращать ошибки. Самые частые:
- **BadRequest (400)** – неверный запрос (например, неправильный параметр, превышена длина текста, бот не в чате и пр.). Нужно исправить логику, проверить параметры.
- **Unauthorized (401)** – токен бота неверный.
- **Forbidden (403)** – бот не может выполнить действие (например, писать в чат, откуда его удалили, или банить админа).
- **NotFound (404)** – например, пытаетесь удалить или отредактировать несуществующее (или уже удалённое) сообщение.
- **TooManyRequests (429)** – лимит запросов, Telegram попросил притормозить (в exception RetryAfter есть поле retry_after с кол-вом секунд) .
- **Internal (500)** – ошибка на стороне Telegram, обычно можно повторить позже.
Aiogram преобразует коды ошибок в исключения (TelegramBadRequest, TelegramForbiddenError, TelegramRetryAfter, TelegramServerError и т.п. в aiogram.exceptions). Их можно ловить и обрабатывать.
Например, при отправке сообщения может вылететь TelegramForbiddenError если бот заблокирован. Это можно поймать в try/except вокруг bot.send_message. Или глобально через error_handler с фильтром по TelegramForbiddenError.
Используйте **декоратор rate_limit или middleware Throttling** для ограничения частоты вызовов методов, чтобы избежать FloodWait (см. раздел Throttling aiogram, если нужно).
## **Webhook vs Long Polling**
Для получения обновлений Telegram бот может использовать:
- **Long Polling (getUpdates)** – бот сам опрашивает сервера Telegram, спрашивая обновления. Мы уже используем его через dp.start_polling(). Это проще в настройке (не нужен сервер с HTTPS), но требует постоянного запущенного скрипта и может быть менее эффективным при масштабировании.
- **Webhook** – Telegram сам POST-ит новые обновления на ваш веб-сервер по заданному URL. Это более сложная настройка, так как нужен **публичный адрес с HTTPS**. Зато снижается задержка получения сообщений и бот может работать внутри веб-приложения.
**Polling** подходит для разработки и небольших ботов. **Webhook** – для production, когда нужен быстрый отклик и надежность, либо когда бот развернут на платформе как Heroku, AWS и проч., ожидающих входящие запросы.
### **Настройка Webhook в aiogram**
Aiogram 3.x не предоставляет единый метод start_webhook как в v2, вместо этого предлагает гибкую интеграцию с веб-серверами (aiohttp, FastAPI, Flask и др.).
Рассмотрим вариант с aiohttp (т.к. aiogram сам использует его):
1. **Подготовьте веб-приложение aiohttp.**
2. **Создайте обработчик запросов** для пути вебхука, и передайте его aiogram’у.
3. **Зарегистрируйте хук старта** для установки webhook у Telegram.
4. **Запустите веб-сервер.**
Aiogram облегчает пункты 2 и 3: есть класс SimpleRequestHandler и функция setup_application в модуле aiogram.webhook.aiohttp_server.
Пример (упрощённый) взят из документации :
```
from aiohttp import web
from aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application
TOKEN = "<BOT TOKEN>"
WEBHOOK_PATH = "/webhook"
WEBAPP_HOST = "0.0.0.0"
WEBAPP_PORT = 3000
WEBHOOK_URL = "https://<your-domain>/webhook"# полный URL до вашего вебхука
dp = Dispatcher()
bot = Bot(TOKEN)
# Регистируем обработчики, подключаем роутеры, как обычно...
# dp.include_router(...)
# Функция, выполняющая установку вебхука на старте
async def on_startup(bot: Bot):
await bot.set_webhook(WEBHOOK_URL)
dp.startup.register(on_startup)
# Создаем веб-приложение
app = web.Application()
# Регистрируем SimpleRequestHandler, чтобы aiohttp принимал запросы и передавал их dp
SimpleRequestHandler(dispatcher=dp, bot=bot).register(app, path=WEBHOOK_PATH)
# Настраиваем запуск и остановку dp вместе с веб-приложением
setup_application(app, dp, bot=bot)
# Запуск приложения (ssl_context нужен если сами поднимаете HTTPS, иначе через reverse proxy)
web.run_app(app, host=WEBAPP_HOST, port=WEBAPP_PORT)
```
**Пояснения:**
- Мы указали WEBHOOK_PATH = "/webhook" – Telegram будет посылать обновления на этот путь вашего сайта. Полный URL мы собрали в WEBHOOK_URL (должен быть HTTPS и реальный домен).
- Функция on_startup вызывает bot.set_webhook с нашим URL . Можно также передать certificate=FSInputFile("public.pem") если используете самоподписанный сертификат , и secret_token="секретный_токен" для защиты (этот токен Telegram будет слать в заголовке X-Telegram-Bot-Api-Secret-Token).
- dp.startup.register(on_startup) привязывает эту функцию к событию запуска (то есть перед первым запросом).
- SimpleRequestHandler берет на себя создание aiohttp route, который слушает WEBHOOK_PATH и передает входящие JSON-ы в диспетчер .
- setup_application устанавливает хуки on_startup/on_shutdown aiohttp, чтобы запустить dp при старте сервера и корректно его завершить при остановке .
- web.run_app запускает aiohttp сервер на указанном хосте/порту. В продакшене обычно host=127.0.0.1 и порт какой-то, а перед ним ставится nginx или др. reverse proxy, который слушает 443 порт и проксирует на локальный.
**HTTPS и сертификаты:** Telegram требует валидного SSL-сертификата. Можно использовать бесплатный от Let’s Encrypt. Если не можете – Telegram позволяет использовать самоподписанный, но нужно при setWebhook передать certificate (публичный ключ) . Aiogram FSInputFile для этого подходит. Также, если у вас платформа с встроенным HTTPS (например, серверless функции), вам, возможно, ничего делать не надо – просто укажите URL.
**Webhook secret token:** Это опциональный параметр, который повышает безопасность – вы задаёте секрет при set_webhook, и Telegram будет в каждом POST запросе добавлять заголовок с этим токеном. SimpleRequestHandler в aiogram может автоматически проверять этот токен. Если вы хотите использовать, передайте secret_token=... и в SimpleRequestHandler(secret_token=...).
**Без веб-фреймворка:** Если не хотите aiohttp, aiogram позволяет получить обновление в виде словаря и вручную скормить его диспетчеру: await dp.feed_update(bot, update) где update – объект aiogram.types.Update (или словарь, тогда aiogram сам преобразует). Это нужно, например, если вы интегрируете с Flask/FastAPI: там в вашем POST handler вы получаете JSON, делаете Update(**json_data) (pydantic модель), и вызываете dp.feed_update. Больше подробностей – в официальных примерах и документации (раздел Webhook “With using other web framework”).
**Polling vs Webhook – что выбрать?** Polling проще – запустил и работает. Webhook требует наличия сервера 24/7 с HTTPS. Если бот критичен и должен быстро реагировать – webhook лучше (опыт показывает, что polling может иногда задерживать сообщения, хотя в целом тоже очень быстрый). Webhook также экономит ресурсы: Telegram присылает апдейты по факту, нет постоянных запросов. Но webhook чуть сложнее тестировать (нужен внешний URL, хотя можно использовать ngrok или похожие туннели для разработки). Некоторые хостинги (например, AWS Lambda) требуют использовать webhook, т.к. не позволяют постоянный опрос.
В итоге, для **разработки/теста** используйте polling. Для **боевого бота** – webhook, если есть возможность развернуть веб-сервис. Aiogram поддерживает оба режима, переключение – буквально запуск либо dp.start_polling, либо запуск aiohttp с настроенным webhook.
## **Обработка ошибок и логирование (подробности)**
Мы уже касались ошибок и логирования ранее, здесь кратко резюмируем лучшие практики:
- **Используйте logging:** на уровне INFO логируйте основные события (запуск бота, внешние запросы, важные действия), на уровне ERROR – непредвиденные ошибки. Никогда не отсылайте пользователю traceback – вместо этого выводите его в лог, а пользователю давайте понятное сообщение.
- **Ловите ожидаемые исключения:** например, MessageNotModified при попытке отредактировать сообщение тем же текстом – можно игнорировать, или BotBlocked – можно перестать слать сообщения этому пользователю и пометить в БД.
- **Глобальный обработчик ошибок:** настройте хотя бы логирование через него, как показано выше. Можно также отправлять уведомления админам о критических падениях:
```
@dp.error()
async def on_error(event: ErrorEvent):
logging.exception(f"Unhandled error: {event.exception}")
try:
await bot.send_message(admin_id, f"❗️ Ошибка: {event.exception}")
except Exception:
pass
```
- Здесь мы используем event.exception и уведомляем администратора. Делать это стоит осторожно, чтобы не зациклить ошибки.
- **Ошибки сетевого уровня:** Aiogram сам пытается повторно подключаться при потере соединения, не нужно вручную перезапускать бота при кратковременных проблемах. Если Telegram API не отвечает, aiogram выдаст NetworkError – можно настроить авто-рестарт или просто логировать и ждать, когда соединение восстановится.
- **KeyboardInterrupt (Ctrl+C):** Aiogram корректно его обрабатывает, завершая polling. Если нужно при завершении что-то сделать (сохранить данные), используйте dp.shutdown callback.
- **Unhandled updates:** Бывает, бот получает обновления, для которых нет хендлера (например, вы не обрабатываете chat_member изменения). Aiogram их просто проигнорирует. Если хотите узнать, что пропустили – включите DEBUG-лог, там будет видно приходящие обновления и info о том, найдены ли хендлеры.
## **Примеры архитектуры и шаблонов**
Создание нестандартных ботов требует грамотной организации кода. Вот несколько рекомендаций и шаблонов, которые помогут поддерживать проект чистым и расширяемым:
1. **Разделение доступа по уровням:** Если бот имеет команды как для обычных пользователей, так и для админов – разделите их по разным Router. Например, user_router и admin_router. Перед добавлением admin_router в Dispatcher можно повесить на него фильтр, который отсекает всех, кроме админов:
```
admin_router.message.filter(IsAdminFilter())# свой фильтр проверки admin_id
```
1. Тогда все хендлеры внутри admin_router будут защищены этим фильтром, и вам не придётся в каждый декоратор вставлять проверку.
2. **Конфигурация через файлы/env:** Не хардкодьте токен, список админов и прочее в коде. Используйте config.py или .env файлы. Например, в config.py:
```
from pydantic import BaseSettings
class Settings(BaseSettings):
bot_token: str
admin_ids: list[int] = []
settings = Settings(_env_file='.env')
```
2. Тогда в коде settings.bot_token и settings.admin_ids доступны. Pydantic удобно валидирует данные окружения.
3. **Хранение состояния и данных:** Если бот предполагает хранение данных (например, результаты опросов, пользовательские профили), рассматривайте использование базы данных. Популярный выбор – SQLite для простых случаев или PostgreSQL/MySQL для более серьёзных. Для интеграции можете использовать SQLAlchemy или Peewee. Aiogram не навязывает способа хранения, это на вашу разработческую часть. Главное – не храните большие данные в FSM-хранилище (оно для временных данных, связанных с диалогом).
4. **Обработка команд / помощь пользователю:** Реализуйте команду /help, в ней опишите все возможности бота. При обновлении функционала не забывайте обновлять описание. Также настройте описание бота и меню команд через BotFather или методом set_my_commands – тогда пользователям будет проще пользоваться ботом.
5. **Управление ботом:** Если бот публичный, добавьте команды /start (начало), /help (помощь). Если бот в группе – возможно, нужен /settings для настроек админом (которые вы можете хранить в БД). Для приватных ботов подумайте об обработке неизвестных сообщений – например, если бот не понял команду, можно отправить краткую справку или кнопки.
6. **Классическое разделение по слоям:**
- **loader.py (или main.py)** – инициализация Bot, Dispatcher, возможно, базы данных, загрузка настроек. Подключение всех модулей, запуск polling/webhook.
- **models.py** – описание моделей БД, если есть.
- **services/** – утилиты, например, функции для взаимодействия с внешними API, для вычислений.
- **middlewares/** – пользовательские middleware (например, Throttling, Logging, Environment).
- **filters/** – пользовательские фильтры (например, IsAdminFilter).
- **states/** – описание StatesGroup для FSM сценариев.
- **handlers/** – пакеты:
- handlers/private/ – хендлеры для личных сообщений;
- handlers/groups/ – для групповых (если бот используется в группах);
- handlers/admin/ – команды админа;
- … либо по функциональности (например, handlers/shop/, handlers/games/).
- **keyboards/** – можно хранить код генерации клавиатур отдельно, особенно если они сложные.
- **utils/** – разные вспомогательные вещи (например, функция форматирования текстов, парсинг даты, и т.п.).
Такой каркас можно взять из существующих шаблонов – сообщество aiogram выработало несколько: на GitHub есть репозиторий [Latand/aiogram-bot-template](https://github.com/Latand/aiogram-bot-template) и [Tishka17/tgbot_template](https://github.com/Tishka17/tgbot_template). Они предлагают готовую структуру с примерами.
2. **Dependency Injection (DI):** Aiogram 3.x позволяет передавать в хендлеры не только Message или CallbackQuery, но и другие объекты, если они зарегистрированы. Например, можно **пробросить в хендлер** объект базы данных или сессии. Делается через dp["<name>"] = obj (в словарь диспетчера помещаем зависимость) и специальный фильтр-флаг, но это более advanced техника. Проще: вы можете в middleware добавить объект в data, и он будет доступен как аргумент. Например, сделайте data["db"] = Session() в middleware – и любой хендлер с параметром db получит эту сессию. Это и есть простая реализация DI через middleware.
3. **Отдельный запуск под тесты/DevOps:** Если планируется комплексный бот, удобно вынести конфигурацию запуска – например, чтобы запускать как polling в отладочном режиме и как webhook на проде. Это можно сделать условиями в main или через аргументы командной строки. Aiogram – чисто библиотека, так что свобода за вами.
4. **Документирование кода:** Несмотря на то, что бот – интерактивная вещь, не пренебрегайте docstring’ами и комментариями. Особенно документируйте сложные переходы состояний и нетривиальные фильтры, чтобы вашим (или чужим) глазам через пару месяцев было понятно, что происходит.
5. **Сообщество и поддержка:** Если сомневаетесь в решении архитектуры, спросите совет у сообщества (например, в Telegram чате [@aiogram_ru](https://t.me/aiogram_ru)). Там часто обсуждаются лучшие практики. Кроме того, официальная документация aiogram обновляется – следите за релизами, возможно появление новых удобных инструментов.
---
На этом наше подробное руководство по aiogram 3.x завершается. Мы рассмотрели все ключевые компоненты: от базовой настройки бота до расширенных возможностей. Вооружившись этой информацией, вы можете создавать Telegram-ботов любой сложности – от простого эхо-бота до полноценного ассистента с меню, состояниями и внешними интеграциями. Удачи в разработке!